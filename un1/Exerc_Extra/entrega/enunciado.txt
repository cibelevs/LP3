ğŸ§¾ ExercÃ­cio PrÃ¡tico â€“ Sistema de Processamento de Entregas

    Durante o perÃ­odo de festas de fim de ano, uma empresa de logÃ­stica e entregas 
    rÃ¡pidas enfrenta um volume extremo de solicitaÃ§Ãµes simultÃ¢neas vindas de aplicativos
    parceiros, e-commerce e atendimento corporativo.

    Para evitar atrasos e garantir consistÃªncia nas operaÃ§Ãµes, vocÃª foi contratado
    para desenvolver um sistema concorrente de processamento de entregas, aplicando 
    o padrÃ£o Produtorâ€“Consumidor.

    O sistema deve permitir que mÃºltiplas fontes gerem solicitaÃ§Ãµes de entrega ao
    mesmo tempo e mÃºltiplos consumidores as processem em paralelo, respeitando prioridades
    de urgÃªncia e evitando condiÃ§Ãµes de corrida.

âš™ï¸ Requisitos
1. Estrutura BÃ¡sica

    a) Classe Entrega
        ID Ãºnico da entrega
        Nome do cliente
        EndereÃ§o de destino
        DistÃ¢ncia (em km)
        Prioridade (URGENTE, NORMAL, ECONOMICA)
        Timestamp de criaÃ§Ã£o

    b) Fila de Entregas
        Tipo: PriorityBlockingQueue<Entrega> (capacidade inicial de 30)
        OrdenaÃ§Ã£o:
        Prioridade (URGENTE > NORMAL > ECONOMICA)
        Tempo de criaÃ§Ã£o (mais antigo primeiro)

    c) Classe GerenciadorVeiculos
        Armazena veÃ­culos e disponibilidade em ConcurrentHashMap<String, Boolean>
        Usa ReentrantReadWriteLock
        MÃ©todos:
        consultarDisponibilidade()
        reservarVeiculo()
        liberarVeiculo()

2. Produtores
    Classe GeradorPedidos
    Representa canais: App, E-commerce, Corporativo
    Gera entregas aleatÃ³rias continuamente
    Insere na fila com put()
    Atraso: 100â€“250 ms
    Gera pelo menos 15 entregas cada
    Usa ExecutorService.newFixedThreadPool(3)

3. Consumidores

    Classe Despachante
    Remove entregas com take()
    Verifica disponibilidade de veÃ­culo antes de despachar
    Simula tempo de despacho (150â€“400 ms)
    Atualiza disponibilidade com locks
    Registra entregas realizadas e pendentes (sem veÃ­culo)
    ExecutorService
    Executors.newFixedThreadPool(4)
    Processa atÃ© a fila esvaziar
    Usa poll(timeout) para detectar o fim
    SincronizaÃ§Ã£o
    Usa ReentrantLock ou AtomicInteger para contadores compartilhados

4. Monitoramento

    Thread de Monitoramento
    A cada 3 s, exibir:
    Tamanho atual da fila
    Entregas realizadas
    Entregas pendentes
    Taxa mÃ©dia (entregas/segundo)
    RelatÃ³rio Final
    Total gerado
    Realizadas / Pendentes
    Tempo total
    Estado final dos veÃ­culos

ğŸ§± RestriÃ§Ãµes

    âœ… Usar:
    PriorityBlockingQueue
    ExecutorService
    ReentrantLock / ReentrantReadWriteLock
    ConcurrentHashMap
    Tratamento de InterruptedException

    ğŸš« Proibido:

    synchronized, wait(), notify(), notifyAll()

    Busy waiting sem propÃ³sito

ğŸ–¥ï¸ SaÃ­da Esperada (exemplo ilustrativo)
[App] Gerou: Entrega#1 [URGENTE] Ana Lima - Rua A, 12km (10:03:21.123)
[E-commerce] Gerou: Entrega#2 [NORMAL] Pedro Souza - Av. B, 8km (10:03:21.215)
[Corporativo] Gerou: Entrega#3 [ECONOMICA] Maria Rocha - Rua C, 15km (10:03:21.299)

[Despachante-1] Processando: Entrega#1 [URGENTE] Ana Lima - 12km
[Despachante-2] Processando: Entrega#2 [NORMAL] Pedro Souza - 8km
[Despachante-3] REJEITADO (sem veÃ­culo): Entrega#3 - 15km

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MONITORAMENTO EM TEMPO REAL  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Fila atual      : 12 entregas â”‚
â”‚ Realizadas      : 18          â”‚
â”‚ Pendentes       : 2           â”‚
â”‚ Taxa mÃ©dia      : 5.4 ent/s   â”‚
â”‚ Tempo decorrido : 6s          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜